<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Создание высоконагруженной системы доставки рекламы на базе OpenX</title>

    <!-- Bootstrap -->
    <link href="/css/bootstrap.min.css" rel="stylesheet">

    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <link href="/css/style.css" rel="stylesheet" type="text/css" />
    <link href="/css/syntax.css" rel="stylesheet" type="text/css" />

  </head>
  <body>
    <!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-7476874-1', 'kolia.pp.ru');
  ga('require', 'displayfeatures');
  ga('send', 'pageview');

</script>
<!-- Google Analytics -->

    <article id="post-289" class="post-289 post type-post status-publish format-standard hentry category-highload category-onbus category-44 tag-openx tag-44 tag--">
	<header class="entry-header">
		<h1 class="entry-title">Создание высоконагруженной системы доставки рекламы на базе OpenX</h1>

		<div class="entry-meta">
			Posted on <a href="http://blog.denivip.ru/index.php/2010/10/openx-highload/" title="21:58" rel="bookmark"><time class="entry-date" datetime="2010-10-09T21:58:39+00:00" pubdate>09.10.2010</time></a><span class="byline"> by <span class="author vcard"><a class="url fn n" href="http://blog.denivip.ru/index.php/author/kolia/" title="View all posts by Nikolay Morev" rel="author">Nikolay Morev</a></span></span>		</div><!-- .entry-meta -->
	</header><!-- .entry-header -->

	<div class="entry-content">
		<p>This post is also available in: <a href="http://blog.denivip.ru/index.php/2011/02/openx-highload-en/?lang=en">Английский</a></p><p><a href="http://blog.denivip.ru/wp-content/uploads/2010/10/0330_openx_390x220.jpg"><img src="http://blog.denivip.ru/wp-content/uploads/2010/10/0330_openx_390x220.jpg" alt="" title="Лого OpenX" width="390" height="220" class="aligncenter size-full wp-image-321" /></a></p>
<p><a href="http://www.openx.org/">OpenX</a> &ndash; это открытый рекламный сервер для управления рекламой на веб-сайтах и доставки рекламных кампаний до потребителей. На сегодняшний день это фактически единственное доступное открытое решение, которое можно установить на собственный сервер и модифицировать под свои потребности. Обзор и небольшую демонстрацию этого продукта мы уже представляли ранее в статье <A HREF="http://blog.denivip.ru/index.php/2010/07/показ-рекламы-в-системе-openx/">Показ рекламы в системе OpenX</A></p>
<p>В этой статье мы постарались свести воедино всю имеющуюся в сети информацию о том, какие меры можно предпринять для того, чтобы выжать максимум производительности из серверов доставки рекламы в том случае, если вы решили использовать OpenX.</p>
<p><span id="more-289"></span></p>
<p>С этой задачей мы столкнулись в ходе создания системы, которая должна была обеспечить стабильную доставку рекламы при условии пиковой посещаемости рекламной площадки до одного миллиона одновременных посетителей. Перед тем, как начать проектирование это число, заданное заказчиком, необходимо свести к более измеримым показателям: число запросов, которое система способна обслуживать в единицу времени, или среднее время ответа при заданном количестве одновременных соединений. Получаются они исходя из предположений о том, какие страницы сайта с какой частотой будут посещаться и какие рекламные материалы на них будут представлены. Это все равно будет довольно приблизительная оценка, но по крайней мере теперь мы можем сравнивать ее с показателями, полученными при выполнении нагрузочных тестов.</p>
<p><H2>Измерение показателей производительности</H2></p>
<p>Перед началом оптимизации вашей установки OpenX и на каждой итерации улучшений полезно фиксировать показатели производительности системы, чтобы понимать какой эффект дают те или иные изменения. Для этого разработчики OpenX рекомендуют использовать <a href="http://jakarta.apache.org/jmeter/">Apache JMeter</a>, в котором можно создавать довольно сложные сценарии тестирования и получать подробную статистику по каждому выполненному в ходе теста запросу. На странице документации для разработчиков OpenX имеется <a href="https://developer.openx.org/wiki/display/DOCS/Performance+Testing">набор готовых сценариев для JMeter</a>. Перед тестированием постарайтесь исключить все возможные факторы, влияющие на результаты теста и не связанные непосредственно с производительностью OpenX, такие как производительность и загруженность машины, с которой производится тестирование, загруженность каналов связи между серверами OpenX и тестовым компьютером. Параметры теста, которые можно варьировать включают количество одновременных соединений и общее количество запросов в ходе теста. Чтобы увидеть максимальную производительность системы, количество одновременных соединений следует задать равным или немного большим, чем количество ядер, обрабатывающих запросы. Чтобы увидеть производительность под реальной нагрузкой, задайте число соединений равное проектируемой нагрузке. Важно следить за тем, чтобы процент запросов, которые завершились с ошибкой был равен 0 или около этого значения.</p>
<p>Кроме того, мы рекомендуем в дополнение к последней версии 2.4 скачать <a href="http://code.google.com/p/jmeter-plugins/">набор плагинов для JMeter</a>, из которых весьма полезными могут быть следующие: Ultimate Thread Group для гибкого задания динамики количества одновременных соединений в ходе тестирования и Response Times vs Threads и Transaction Throughput vs Threads для построения различных графиков по результатам теста.</p>
<p><a href="http://blog.denivip.ru/wp-content/uploads/2010/10/paper_html_m6ec6eb79.gif"><img src="/texts/denivip/assets/paper_html_m6ec6eb79.gif" alt="" title="Время ответа при изменении количества одновременных запросов" width="300" height="166" class="aligncenter size-medium wp-image-305" /></a><br />
<a href="http://blog.denivip.ru/wp-content/uploads/2010/10/paper_html_m1310f926.gif"><img src="/texts/denivip/assets/paper_html_m1310f926.gif" alt="" title="Пропускная способность при изменении числа одновременных запросов" width="300" height="166" class="aligncenter size-medium wp-image-307" /></a></p>
<p>Если вы работаете с системой, которая уже введена в эксплуатацию, очень полезным будет анализ графиков загрузки серверов системы, строящихся в различных системах мониторинга серверов типа Zabbix, Cacti и т.п. Сами разработчики OpenX <a href="https://developer.openx.org/wiki/display/DOCS/Performance+Monitoring">рекомендуют  использовать Ganglia</a>. </p>
<p><a href="http://blog.denivip.ru/wp-content/uploads/2010/10/paper_html_3724d1a1.gif"><img src="/texts/denivip/assets/paper_html_3724d1a1.gif" alt="" title="Время ответа при числе одновременных соединений от 1 до 1500" width="300" height="166" class="aligncenter size-medium wp-image-308" /></a></p>
<p> Производительность базовой установки OpenX на одном среднем сервере по информации из различных источников составляет от 30 до 100 запросов в секунду в зависимости от используемых настроек. Исходя из этого необходимо решить, какое количество серверов и сколько ядер на каждом из них будет обрабатывать ваши запросы. Очевидно, что разброс от 30 до 100 достаточно велик и только от сделанных вами улучшений будут зависеть конкретные цифры.</p>
<p><a href="http://blog.denivip.ru/wp-content/uploads/2010/10/paper_html_6bd62841.gif"><img src="/texts/denivip/assets/paper_html_6bd62841.gif" alt="" title="Пропускная способность системы при изменении числа одновременных соединений от 1 до 1500" width="300" height="166" class="aligncenter size-medium wp-image-309" /></a><br />
<H2>Серверная архитектура</H2></p>
<p>Первым делом рассмотрим архитектуру серверов нашей системы. Естественно, что для использования такой относительно медленной системы как OpenX, производительность которой фундаментально ограничена необходимостью выполнения PHP-скриптов для доставки рекламы и логирования информации о показах, необходимо изначально закладывать в архитектуру возможность горизонтального масштабирования, то есть легкого добавления дополнительных серверов с целью повышения производительности. Такая возможность изначально заложена в OpenX. Этому способствует как открытость самого продукта, так и использование широко распространенных открытых технологий, а также то, что его легко можно разделить на три основные части по их функциональному назначению: веб-интерфейс управления рекламой и статистики, движок доставки рекламы (он принимает решение о выдаче рекламы и осуществляет логирование), движок обработки статистики и вычисления приоритетов кампаний.</p>
<p>Возможны различные варианты распределения компонентов OpenX по серверам. Разработчиками системы предлагается распределенный вариант, схему работы которого можно обобщить следующей схемой:</p>
<p><a href="http://blog.denivip.ru/wp-content/uploads/2010/10/paper_html_c0b090.jpg"><img src="/texts/denivip/assets/paper_html_c0b090.jpg" alt="" title="Распределенная схема" width="300" height="273" class="aligncenter size-medium wp-image-311" /></a></p>
<p>Здесь функции интерфейса управления кампаниями и обработки сырых статистических данных выносятся на отдельный сервер, а функции доставки распределяются на необходимое количество серверов, так как именно на них ложится основная нагрузка в ходе работы системы. Каждый узел доставки работает с собственным сервером MySQL, настроеным на репликацию данных с главного сервера базы данных. При этом сырые данные логирования хранятся локально и периодически обобщаются скриптом сбора распределенной статистики, который запускается на главном сервере и пишет обработанную статистику в основной сервер БД. Таким образом удается снизить нагрузку на основной сервер БД и распределить запросы к скриптам доставки на любое количество серверов. Подробнее об этом варианте архитектуры можно прочитать в документации OpenX и на других ресурсах [<a href="http://www.openx.org/docs/2.8/adminguide/Distributed statistics">1</a>, <a href="http://openx.org/docs/whitepapers/distributed-statistics">2</a>, <a href="http://www.openxtips.com/2009/09/tip-28-simple-openx-scaling/">3</a>].  </p>
<p>Мы немного видоизменили данную схему, принимая во внимание имеющееся у нас в распоряжение оборудование и информацию, собранную при выполнении нагрузочных тестов. Все поступающие запросы обрабатывает один фронтенде, который берет на себя распределение запросов на доставку между PHP-бэкендами и обработку запросов админского интерфейса. Движок обработки статистики и вычисления приоритетов, а также сервер Memcached для кэширования информации, получаемой из БД, также выполняются на этом сервере. Все эти задачи требуют относительно малой вычислительной мощности. Основная же нагрузка ложится на несколько серверов PHP-бэкенда.  База данных реплицируется с master-сервера на два slave-сервера с целью оптимизации производительности и обеспечения сохранности данных. Таким образом мы улучшили предыдущую схему, освободив серверы PHP-бэкенда от несвойственных ему функций (сервер БД), и можем масштабировать различные аспекты системы (серверы БД, серверы PHP-бэкенда) независимо друг от друга.</p>
<p><a href="http://blog.denivip.ru/wp-content/uploads/2010/10/paper_html_m769686b1.jpg"><img src="/texts/denivip/assets/paper_html_m769686b1.jpg" alt="" title="Схема с выделенными серверами БД" width="198" height="300" class="aligncenter size-medium wp-image-312" /></a></p>
<p> Несколько слов о настройке программного обеспечения на серверах. Все серверы работают под управлением ОС Linux. На фронтенде установлен высокопроизводительный HTTP-сервер Nginx, который отдает рекламные креативы и прочую статику и проксирует запросы на выполнение скриптов PHP. На бэкендах установлена связка spawn-fcgi + PHP&nbsp;5.1. В версии PHP&nbsp;5.3 появилось несколько улучшений в плане производительности, в частности интегрирован модуль php-fpm, однако поддержка работы OpenX с этой версией пока реализована не до конца. </p>
<p>При редактировании конфигов используемого ПО следует исключить все факторы, которые могут ограничивать возможное число одновременных соединений: максимальное число соединений и количество рабочих процессов в Nginx, лимиты Linux на количество открытых соединений и файлов (не забыть выставить на машине, с которой проводятся нагрузочные тесты), лимиты Memcached и MySQL на количество одновременных соединений и т.д. </p>
<p>Основные рекомендации по настройке параметров ОС, почерпнутые из различных источников [<A HREF="https://developer.openx.org/wiki/display/DOCS/Linux">1</A>, <A HREF="http://www.sherin.co.in/openxhandbook/">2</A>, <A HREF="http://www.sherin.co.in/openxcluster121/">3</A>] сводятся к следующему:</p>
<ul>
<li>Отключить запуск всех ненужных сервисов и скриптов cron.</li>
<li>Задать опцию noatime в /etc/fstab для файловых систем, чтобы при доступе к ФС не тратилось время на обновление информации о времени последнего доступа, связанной с каждым файлом.</li>
<li>В файле /etc/sysctl.conf задать следующие параметры:</li>
</ul>
<div class="codecolorer-container text default" style="overflow:auto;white-space:nowrap;width:540px;"><table cellspacing="0" cellpadding="0"><tbody><tr><td class="line-numbers"><div>1<br />2<br />3<br />4<br /></div></td><td><div class="text codecolorer"># чтобы некорректно закрытые соединения автоматически отваливались через 10 секунд<br />
net.ipv4.tcp_fin_timeout = 10 <br />
# чтобы увеличить число доступных local-портов для исходящих соединений<br />
net.ipv4.ip_local_port_range = 16384 65536</div></td></tr></tbody></table></div>
<ul>
<li> В файле /etc/security/limits.conf задать для отмены ограничения на количество открытых файлов:</li>
</ul>
<div class="codecolorer-container text default" style="overflow:auto;white-space:nowrap;width:540px;"><table cellspacing="0" cellpadding="0"><tbody><tr><td class="line-numbers"><div>1<br /></div></td><td><div class="text codecolorer">* &nbsp; soft &nbsp; &nbsp;nofile &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;65000</div></td></tr></tbody></table></div>
<p>Для spawn-fcgi рекомендуется задать число тредов чуть большее, чем число доступных ядер. Число процессов PHP можно оставить равным 1, но для увеличения надежности можно поставить и чуть побольше. При регулировке этих параметров нужно обращать внимание на значений показателя Load average при полной загрузке системы. Оно должно быть приблизительно равно числу доступных ядер.</p>
<p>При настройке БД &mdash; включить репликацию, задать максимальное число соединений. Обязательно включить в конфиге OpenX постоянные соединения с MySQL: в разделе [database] установить persistent=1. Другие параметры MySQL (по материалам <A HREF="http://www.sherin.co.in/openxhandbook/">1</A>, <A HREF="https://developer.openx.org/wiki/display/DOCS/Tuning+MySQL">2</A>, <A HREF="https://developer.openx.org/wiki/display/DOCS/MySQL+Table+Types+Notes">3</A>):</p>
<div class="codecolorer-container text default" style="overflow:auto;white-space:nowrap;width:540px;"><table cellspacing="0" cellpadding="0"><tbody><tr><td class="line-numbers"><div>1<br />2<br />3<br /></div></td><td><div class="text codecolorer">[mysqld]<br />
; максимальное число соединений<br />
max_connections =2048</div></td></tr></tbody></table></div>
<p> В конфиге OpenX увеличить буферы сортировки для обработки статистики:</p>
<div class="codecolorer-container text default" style="overflow:auto;white-space:nowrap;width:540px;"><table cellspacing="0" cellpadding="0"><tbody><tr><td class="line-numbers"><div>1<br />2<br /></div></td><td><div class="text codecolorer">[databaseMysql]<br />
statisticsSortBufferSize &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 536868864</div></td></tr></tbody></table></div>
<p> Для хранения таблиц по-умолчанию используется тип MyISAM, т.к. он быстрее работает. Однако проблема с MyISAM в том, что таблица полностью блокируется на время записи.  Обычно это не сильно влияет на производительность, но в случае высоконагруженных систем может повлиять существенно, особенно во время запуска скрипта сбора статистики, поэтому нужно осуществлять его мониторинг для того, чтобы убедиться, что он не выполняется слишком долго. Для установок OpenX, в которых используется выделенный сервер БД с хорошей производительностью рекомендуется использовать InnoDB. Хотя работа с таблицами этого типа в целом и медленнее, но в них реализована построчная блокировка при записи. В общем случае нужно проводить нагрузочные тесты и мониторинг на реальной нагрузке по каждому варианту и оценивать, что подходит больше.</p>
<p> Для Nginx выставлены следующие настройки:</p>
<div class="codecolorer-container text default" style="overflow:auto;white-space:nowrap;width:540px;"><table cellspacing="0" cellpadding="0"><tbody><tr><td class="line-numbers"><div>1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br /></div></td><td><div class="text codecolorer"># число рабочих процессов равно числу ядер<br />
worker_processes &nbsp; 16;<br />
# лимит открытых файлов для каждого рабочего процесса<br />
worker_rlimit_nofile &nbsp;8192;<br />
# задаем максимальное число соединений<br />
events {<br />
&nbsp; &nbsp; worker_connections 65000;<br />
&nbsp; &nbsp; use epoll;<br />
}<br />
# включаем сжатие ответов, чтобы ускорить их отдачу и быстрее освобождать соединения<br />
gzip on;<br />
gzip_min_length 1100;<br />
gzip_buffers 64 8k;<br />
gzip_comp_level 3;<br />
gzip_http_version 1.1;<br />
gzip_proxied any;<br />
gzip_types text/plain application/xml application/x-javascript text/css;<br />
# отключаем keep-alive соединения<br />
keepalive_timeout 0;</div></td></tr></tbody></table></div>
<h2>Оптимизация доставки</h2>
<p>Чтобы понять в каком направлении оптимизировать далее, рассмотрим основные факторы, влияющие на производительность системы. Для этого необходимо понимать основные паттерны работы системы. Запросы к системе при заходе одного посетителя на страницу, содержащую баннеры осуществляются следующие: </p>
<ol>
<li>Запрос рекламных материалов<br />
    для каждой зоны или сразу всех. </li>
<li>Запрос<br />
    рекламного креатива (статическая картинка). Его мы не учитываем, так<br />
    как он дает относительно небольшую нагрузку на серверы и легко<br />
    обрабатывается Nginx-ом.</li>
<li>Отправка логирования показа. </li>
<li>Отправка логирования клика. </li>
</ol>
<p>На первом этапе производится запрос на чтение к БД для определения набора баннеров пригодных к показу и выбора подходящего на основе приоритетов и настроек кампаний. Это можно закэшировать, но кэш должен периодически обновляться, чтобы подтягивать обновленные после запуска скрипта вычисления приоритетов. На этапах 3 и 4 производится увеличение счетчика показов в таблице сырой статистики запросом вида INSERT ON DUPLICATE UPDATE. Это уже закэшировать нельзя, но и здесь все-таки есть определенные приемы оптимизации.</p>
<p>Итак лимитирующие факторы: </p>
<ul>
<li> необходимость чтения из БД, </li>
<li> необходимость записи в БД, </li>
<li> скорость выполнения скриптов PHP. </li>
</ul>
<p><H3>Кэширование запросов на чтение</H3></p>
<p>Для оптимизации чтения из БД осуществляем кэширование всей информации, считывающейся из БД. Об этом разработчики OpenX позаботились, встроив в систему хорошую поддержку кэширования, легко расширяемую с помощью несложных плагинов. В базовую поставку входит плагин для файлового кэша и для memcached. Причем в конфиге можно задавать последовательность плагинов, так что если один из них выйдет из строя, то автоматически начинает использоваться другой. Поэтому рекомендуется сразу же включить кэширование, не забыв увеличить максимальное число соединений в сервере Memcached.</p>
<div class="codecolorer-container text default" style="overflow:auto;white-space:nowrap;width:540px;"><table cellspacing="0" cellpadding="0"><tbody><tr><td class="line-numbers"><div>1<br />2<br />3<br />4<br />5<br />6<br /></div></td><td><div class="text codecolorer">[delivery]<br />
cacheExpire=600<br />
cacheStorePlugin=&quot;deliveryCacheStore:oxMemcached:oxMemcached&quot;<br />
[oxMemcached]<br />
memcachedServers=&quot;10.2.35.2:11211&quot;<br />
memcachedExpireTime=600</div></td></tr></tbody></table></div>
<p> В условиях полного кэширования всего, что возможно, запросы к кэшу начинают занимать значительную часть времени обработки рекламного запроса (примерно 20%), поэтому рекомендуется задать следующие настройки сервера Memcached: использовать бинарный протокол, использовать UDP.</p>
<h3>Сокращение числа запросов к БД </h3>
<p> Хотя это может показаться не актуальным в свете кэширования всего подряд, но все-таки запросы время от времени совершаются, не смотря на кэширование, а, во-вторых, отдельные запросы часто бывают связаны с другими накладными расходами, даже если они закэшированы. Например, если вы пишете свои расширения для OpenX, добавляя в схему БД новые признаки для баннеров или других сущностей системы, то с точки зрения удобства разработки и правильности архитектуры вы можете решить хранить это значение в отдельной таблице со связью по ID сущности и получать его в процессе доставки отдельным запросом, написав для его вызова отдельный плагин. Однако все эти архитектурно правильные решения скажутся на производительности, поэтому оптимальнее будет вносить правки непосредственно в основной код OpenX, добавлять колонки непосредственно к базовым таблицам и т.д. Другая возможность по сокращению числа запросов связана с отключением ненужных плагинов доставки.</p>
<p><H3>Оптимизация записи в БД</H3></p>
<p>С замедлением, связанным с необходимостью записи логов доставки отчасти борется архитектура распределенной статистики, рассмотренная ранее. Другой оригинальный подход предложен в статье <A HREF="http://hi-load.php.com.ua/topic/31/">http://hi-load.php.com.ua/topic/31/</A>. Он заключается в том, чтобы писать статистику не в БД, а в файл на диске, что должно быть менее затратно. Для этого вносятся изменения в исходный код системы, а именно в функцию OA_Dal_Delivery_logAction в файле lib\OA\Dal\Delivery\mysql.php, которая и вызывается различными плагинами доставки для записи логов. Кроме того авторам удалось избавиться и от необходимости открывать файл для записи при каждом запросе, передавая данные логирования непосредственно в лог веб-сервера, используя функцию PHP apache_setenv и специальные настройки Apache. Далее логи периодически импортируются в БД простым SQL-запросом LOAD DATA INFILE. Очевидным недостатком такого подхода является зависимость от веб-сервера Apache. Принцип, озвученный в этой статье, можно было бы развить и далее, совсем отказавшись от записи сырых данных в БД. Интересно было бы исследовать возможность их хранения и считывания скриптом обработки статистики с использованием одного из множества набирающих популярность в последнее время key-value хранилищ или NoSQL серверов.</p>
<p><H3>Увеличение скорости выполнения PHP</H3></p>
<p>После выполнения всех перечисленных выше оптимизаций основным и достаточно жестким лимитирующим фактором становится скорость выполнения PHP-скриптов. В первую очередь для ее увеличения необходимо обязательно установить любой из PHP-акселераторов, кэширующих скомпилированный PHP-код. Все они дают примерно одинаковое ускорение в несколько раз. Мы использовали <a href="http://eaccelerator.net/">eAccelerator</a>. Для него рекомендуется задать следующие настройки в файле php.ini:</p>
<div class="codecolorer-container text default" style="overflow:auto;white-space:nowrap;width:540px;"><table cellspacing="0" cellpadding="0"><tbody><tr><td class="line-numbers"><div>1<br />2<br />3<br />4<br />5<br />6<br /></div></td><td><div class="text codecolorer">; размер кэша в разделяемой памяти в мб<br />
eaccelerator.shm_size = 512<br />
; использовать только кэш в памяти<br />
eaccelerator.shm_only = 1<br />
; не использовать сжатие для закэшированного кода<br />
eaccelerator.compress = 0</div></td></tr></tbody></table></div>
<p>По оптимизации кода скриптов доставки разработчики провели значительную работу. Код доставки по большей части независим от остального кода системы и хорошо оптимизирован: не использует дополнительных помимо стандартных библиотек для доступа к БД, не использует классы и объектно-ориентированное программирование вообще, минимизирует количество директив include и require, все дорогостоящие операции кэшируются во внешнем кэше или в глобальных переменных и выполняются максимум 1 раз за время выполнения скрипта. К стандартной поставке OpenX прилагается специальный скрипт для компиляции всех инклюдов в скриптах доставки в один файл. Все эти <a href="https://developer.openx.org/wiki/display/COMM/Delivery+Optimization">правила</a> нужно принимать во внимание разработчикам, которые модифицируют код OpenX или пишут собственные плагины. Для определения узких мест в коде рекомендуется использовать информацию о времени выполнения, полученную под реальной нагрузкой с помощью профайлера встроенного в расширение XDebug для PHP. Выходные файлы профайлера можно просматривать с помощью утилиты WinCacheGrind.</p>
<p><a href="http://blog.denivip.ru/wp-content/uploads/2010/10/paper_html_m4916e3f6.jpg"><img src="/texts/denivip/assets/paper_html_m4916e3f6.jpg" alt="" title="Окно WinCacheGrind" width="300" height="198" class="aligncenter size-medium wp-image-313" /></a></p>
<p>Еще один интересный подход к ускорению скриптов доставки для разработчиков, хорошо знакомых с PHP, &ndash; использование так называемого реального FastCGI (<A HREF="http://habrahabr.ru/blogs/php/64938/">1</A>, <A HREF="http://javascript.ru/blog/TravisBickle/True-FastCGI-dlya-PHP-migraciya-testy">2</A>) совместно с <a href="http://phpdaemon.net/">PHPDaemon</a>. Достоинства этого подхода в сокращении на треть времени выполнения скриптов за счет выполнения кода инициализации только один раз &ndash; во время запуска демона. Недостатки связаны с потенциальной необходимостью вносить значительные изменения в скрипты доставки, сложной ситуацией с утечками памяти в PHP (необходимо периодически перезапускать процесс PHP, теряя преимущества реального FastCGI), необходимостью использовать версию PHP 5.3, в которой значительно улучшен сборщик мусора. </p>
<p>Если вы не считаете нужным лезть в код системы, то полезно будет хотя бы выключить все ненужные плагины в конфиге OpenX. В частности, хороший эффект дает отключение различных плагинов логирования дополнительной информации в разделе конфига [deliveryHooks], группы правил Client плагина deliveryLimitations в разделе [pluginGroupComponents] (инициализация ограничений по браузеру пользователя занимает довольно много времени из-за использования внешней библиотеки phpSniff, причем она выполняется даже, если вы не используете эти ограничения). Можно также полностью отключить логирование различных аспектов доставки в разделе [logging].</p>
<p>Еще один подход направлен на уменьшение количества запросов необходимых для показа баннеров на странице (<A HREF="http://blog.openx.org/12/faster-page-load-times-happier-users/">1</A>, <A HREF="http://www.openxtips.com/2009/07/tip-20-protect-your-site-from-openx-hangs/">2</A>), что к тому же положительно сказывается на скорости загрузки страницы.  При этом один запрос возвращает рекламный код для всех баннеров, отображающихся на одной странице, а не для каждой зоны в отдельности.</p>
<p>В OpenX по-умолчанию включен механизм выполнения скрипта сбора статистики в ходе выполнения скриптов доставки. Это бывает удобно для небольших систем, когда у администратора нет доступа к крону или просто для облегчения процесса установки, но на высоконагруженной системе это недопустимо, так как это будет замедлять доставку баннеров. Скрипт статистики должен выполняться по крону и желательно на отдельной машине (<A HREF="http://www.openxtips.com/2009/08/tip-26-run-the-maintenance-script-manually/">1</A>, <a href="http://www.openx.org/docs/2.8/adminguide/Running maintenance">2</a>).  Для этого в конфиге OpenX необходимо задать параметр </p>
<div class="codecolorer-container text default" style="overflow:auto;white-space:nowrap;width:540px;"><table cellspacing="0" cellpadding="0"><tbody><tr><td class="line-numbers"><div>1<br />2<br /></div></td><td><div class="text codecolorer">[maintenance]<br />
autoMaintenance=0</div></td></tr></tbody></table></div>
<p>И добавить в crontab следующую строку:</p>
<div class="codecolorer-container text default" style="overflow:auto;white-space:nowrap;width:540px;"><table cellspacing="0" cellpadding="0"><tbody><tr><td class="line-numbers"><div>1<br /></div></td><td><div class="text codecolorer">0 * * * * /path/to/php /path/to/openx/scripts/maintenance/maintenance.php www.mydomain.com</div></td></tr></tbody></table></div>
<p><H2>Заключение</H2></p>
<p> Надеемся, что представленная в этой статье информация поможет вам оптимизировать производительность вашего сервера OpenX. Помимо ссылок, встречающихся в тексте статьи, мы также использовали информацию, полученную со следующих ресурсов по OpenX:</p>
<ul>
<li><a href="http://www.openx.org/support/documentation">Пользовательская и админская документация по OpenX</a>. По теме статьи в частности интерес представляет раздел <a href="http://www.openx.org/docs/2.8/adminguide/Managing performance">Managing Performance</a></li>
<li>Наиболее полный источник информации об OpenX <a href="https://developer.openx.org/wiki/pages/listpages-dirview.action?key=COMM">wiki для разработчиков</a>, в частности статья <A HREF="https://developer.openx.org/wiki/display/DOCS/Performance+Tuning">Performance Tuning</A>.</li>
<li>Статьи <A HREF="http://openx.org/docs/whitepapers/performance-tuning">Performance Tuning</A> и <A HREF="http://openx.org/docs/whitepapers/distributed-statistics">Distributed Statistics</A></li>
</ul>

<div style="min-height:33px;" class="really_simple_share really_simple_share_button robots-nocontent snap_nopreview"></div>
		<div style="clear:both;"></div>			</div><!-- .entry-content -->

	<footer class="entry-meta">
		This entry was posted in <a href="http://blog.denivip.ru/index.php/category/highload/" title="Просмотреть все записи в рубрике &laquo;Highload&raquo;" rel="category tag">Highload</a>, <a href="http://blog.denivip.ru/index.php/category/onbus/" title="Просмотреть все записи в рубрике &laquo;Онлайн бизнес&raquo;" rel="category tag">Онлайн бизнес</a>, <a href="http://blog.denivip.ru/index.php/category/%d1%80%d0%b5%d0%ba%d0%bb%d0%b0%d0%bc%d0%b0/" title="Просмотреть все записи в рубрике &laquo;Реклама&raquo;" rel="category tag">Реклама</a> and tagged <a href="http://blog.denivip.ru/index.php/tag/openx/" rel="tag">OpenX</a>, <a href="http://blog.denivip.ru/index.php/tag/%d1%80%d0%b5%d0%ba%d0%bb%d0%b0%d0%bc%d0%b0/" rel="tag">Реклама</a>, <a href="http://blog.denivip.ru/index.php/tag/%d1%80%d0%b5%d0%ba%d0%bb%d0%b0%d0%bc%d0%bd%d1%8b%d0%b9-%d1%81%d0%b5%d1%80%d0%b2%d0%b5%d1%80/" rel="tag">рекламный сервер</a>. Bookmark the <a href="http://blog.denivip.ru/index.php/2010/10/openx-highload/" title="Permalink to Создание высоконагруженной системы доставки рекламы на базе OpenX" rel="bookmark">permalink</a>.
			</footer><!-- .entry-meta -->
        </article><!-- #post-289 -->



    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script>
    <script src="/js/bootstrap.min.js"></script>
    

    <div class="col-md-12" style="margin-top: 6em">
        <p style="text-align: center"><span class="small">Обновлено Mon Jan 2 23:16:57 2017 +0300</span></p>
    </div>

  </body>
</html>
